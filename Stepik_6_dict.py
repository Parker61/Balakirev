# 6.1 Введение в словари

# Подвиг 3. Вводятся данные в формате ключ=значение в одну строчку через пробел. Значениями здесь являются целые числа
# (см. пример ниже). Необходимо на их основе создать словарь d с помощью функции dict() и вывести его на экран командой:
# print(*sorted(d.items())) Sample Input: one=1 two=2 three=3 Sample Output: ('one', 1) ('three', 3) ('two', 2)

l = [[j[0], int(j[1])] for i in input().split() for j in [i.split('=')]]
# print(l)
d = dict(l)
# print(d)
print(*sorted(d.items()))

l = [[i.split('=')[0], int(i.split('=')[1])] for i in input().split()]
d = dict(l)
print(*sorted(d.items()))

l = [i.split('=') for i in input().split()]
for i in d:
    d[i] = int(d[i])
print(*sorted(d.items()))

l = [i.split('=') for i in s.split()]
d = {i: int(v) for i, v in l}

l = [i.split('=') for i in s.split()]
d = {i: int(v) for i, v in l}

print(*sorted({x.split('=')[0]: int(x.split('=')[1]) for x in s.split()}.items()))

# for k, v in [pair.split('=')]
# трюк для создания доп. цикла в списочном выражении. Доп. квадратные скобочки создают внешний список. Получаетя
# список, состоящий из одного элемента ['one', '1'], зато теперь можно организовать цикл обхода элементов внешнего
# списка). Это будет всего один шаг цикла, извлечётся элемент ['one', '1'] и будет автоматически распакован по двум
# переменным цикла k, v. Без внешнего списка, обходится будут элементы самого списка ['one', '1'] по одному, а нам они
# нужны парами).
print(*sorted({k: int(v) for pair in input().split() for k, v in [pair.split('=')]}.items()))

d = {i[:-2]: int(i[-1]) for i in s.split()}  # [:-2] от 0 до -2 с конца, i[-1] последнее значение
# корректно будет работать только до 9. дальше ключи будут кривыми.т.к. при 10 2-хзначной цифре [-1] берётся 0 а не 10
print(*sorted(d.items()))

d = {i: int(v) for i, v in [j.split('=') for j in s.split()]}
print(*sorted(d.items()))

print({k: int(v) for k, v in (i.split('=') for i in s.split())})
print({k: int(v) for i in s.split() for k, v in [i.split("=")]})  # когда мы делаем множественное присваивание,
# происходит распаковка элементов коллекции. Например, key, val = [1, 2],очевидно, что key будет 1, val будет 2...и так
# по очереди проходим по вложенным спискам.

d = dict(list(map(lambda itm: (itm.split("=")[0], int(itm.split("=")[1])), s.split())))

######  Ключами здесь выступают целые числа (см. пример ниже). Необходимо их преобразовать в словарь d
# 5=отлично
# 4=хорошо
# 3=удовлетворительно

import sys

# lst_in = list(map(str.strip, sys.stdin.readlines()))
lst_in = ['5=отлично', '4=хорошо', '3=удовлетворительно']
d = {int(i.split('=')[0]): i.split('=')[1] for i in lst_in}
print(*sorted(d.items()))

d = {int(k): v for i in lst_in for k, v in [i.split('=')]}

d = {int(k): v for k, v in (i.split('=') for i in lst_in)}

d = {int(i[0]): i[2:] for i in lst_in}

# Подвиг 5. Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать
# словарь, затем проверить, существуют ли в нем ключи со значениями: 'house', 'True' и '5' (все ключи - строки).
# Если все они существуют, то вывести на экран ДА, иначе - НЕТ.

lst = list(map(str, input().split()))  # ['вологда=город', 'house=дом', 'True=1', '5=отлично', '9=божественно']
d = {i.split('=')[0]: i.split('=')[1] for i in lst}
for i in lst:
    if i.split('=')[0] in d:
        continue
    else:
        print('НЕТ')
        break
else:
    print('ДА')

d = dict([i.split('=') for i in (input().split())])
for i in d:
    if 'house' in d and 'True' in d and '5' in d:
        continue
    else:
        print('НЕТ')
        break
else:
    print('ДА')

d = {k: v for i in lst for k, v in [i.split('=')]}

d = {k: v for k, v in (i.split('=') for i in s.split())}
for i in s.split():
    if i.split('=')[0] in d:
        continue
    else:
        print('НЕТ')
        break
else:
    print('ДА')

s = 'вологда=город house=дом True=1 5=отлично 9=божественно'
d = dict([i for i in (i.split('=') for i in s.split())])
print('ДА' if 'house' in d and 'True' in d and '5' in d else 'НЕТ')

s = 'вологда=город house=дом True=1 5=отлично 9=божественно'
print(['НЕТ', 'ДА'][{'house', 'True', '5'}.issubset(s.replace('=', ' ').split()[::2])])

s = 'вологда=город house=дом True=1 5=отлично 9=божественно'
print(['НЕТ', 'ДА'][{'house', 'True', '5'}.issubset(dict(i.split('=') for i in s.split()))])

d = {j for i in s.split() for j in i.split('=')}
print(['НЕТ', 'ДА'][all(i in d for i in ['house', 'True', '5'])])

s = 'вологда=город house=дом True=1 5=отлично 9=божественно'
d = dict(i.split('=') for i in s.split())
kyes = ['house', 'True', '5']  # С таким подходом можно изменять список ключей.
# print(['НЕТ', 'ДА'][ sum(1 for i in kyes if i in d)==len(kyes)  ])
print(['НЕТ', 'ДА'][all(i in d for i in kyes)])

# Подвиг 6. Вводятся данные в формате ключ=значение в одну строчку через пробел. Необходимо на их основе создать словарь
# d, затем удалить из этого словаря ключи 'False' и '3', если они существуют. Ключами и значениями словаря  строки

s = 'лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина'
d = dict([[j for j in i.split('=')] for i in s.split()])
key = ['False', '3']
for i in key:
    if i in d:
        del d[i]

for i in key:
    d.pop(i, 'defalt')
print(*sorted(d.items()))

d = {k: v for i in s.split() for k, v in [i.split('=')] if k not in ['False', '3']}

# Подвиг 7. Вводятся номера телефонов в одну строчку через пробел с разными кодами стран: +7, +6, +2, +4 и т.д.
# Необходимо составить словарь d, где ключи - это коды +7, +6, +2 и т.п., а значения - список номеров (следующих в том
# же порядке, что и во входной строке) с соответствующими кодами.

s = '+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890'
di = {k[:2]: k for k in
      s.split()}  # {'+7': '+71232267890', '+6': '+61234576890', '+5': '+52134567890', '+2': '+21234567110'}
d = {}
for key in di:
    d.setdefault(key, [])
    for v in s.split():
        if key == v[:2]:
            d[key].append(v)
print(*sorted(d.items()))

d = dict([[i[:2], [j for j in s.split() if i[:2] == j[:2]]] for i in s.split()])

s = '+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890'
d = {}
for i in s.split():
    d.setdefault(i[:2], [])
    d[i[:2]].append(i)
print(*sorted(d.items()))

s = '+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890'
lst = s.split()
d = {}
for i in lst:
    if i[:2] in d:
        d[i[:2]].append(i)
    else:
        d[i[:2]] = [i]
print(*sorted(d.items()))

# Подвиг 8. Вводятся номера телефонов в формате:
# номер_1 имя_1
# номер_2 имя_2..
# номер_N имя_N
# Необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов для этого имени.
# Обратите внимание, что одному имени может принадлежать несколько разных номеров

import sys

lst_in = list(map(str.strip, sys.stdin.readlines()))
lst_in = ['+71234567890 Сергей', '+71234567810 Сергей', '+51234567890 Михаил', '+72134567890 Николай']
d = {}
for i in lst_in:
    k = i.split()[1]
    if k not in d:
        d[k] = [i.split()[0]]
    else:
        d[k].append(i.split()[0])
print(*sorted(d.items()))

for i in lst_in:
    d.setdefault(i.split()[1], [])
    d[i.split()[1]].append(i.split()[0])

d = {}
for i in lst_in:
    d.setdefault(i.split()[1], []).append(i.split()[0])

d = {}
for i in lst_in:
    v, k = i.split()
    if k not in d:
        d[k] = [v]
    else:
        # d[k]+=[v]
        d[k].append(v)

lst_in = ['+71234567890 Сергей', '+71234567810 Сергей', '+51234567890 Михаил', '+72134567890 Николай']
lst = [i.split() for i in lst_in]
print(
    lst)  # [['+71234567890', 'Сергей'], ['+71234567810', 'Сергей'], ['+51234567890', 'Михаил'], ['+72134567890', 'Николай']]
d = dict([[i[1], [j[0] for j in lst if i[1] == j[1]]] for i in lst])

# Подвиг 9. Пользователь вводит в цикле целые положительные числа, пока не введет число 0. Для каждого числа вычисляется
# квадратный корень (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните
# кэширование данных так, чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее
# вычисленное значение из словаря. При этом на экране должно выводиться:#значение из кэша: <число>

num = int(input())
d = {}
while num:  # num != 0
    if num in d:
        print('значение из кэша:', d[num])
    else:
        d[num] = round(num ** .5, 2)
        print(round(d[num], 2))
    num = int(input())

d = {}
for i in iter(input, '0'):  # пока не будет достигнуто '0'
    if d.get(i):  # если нет key False
        print(f'значение из кэша: {d[i]}')
    else:
        d[i] = round(int(i) ** .5, 2)
        print(d[i])

d = {}
for i in map(int, iter(input, '0')):
    if d.get(i):  # если нет key False
        print(f'значение из кэша: {d[i]}')
    else:
        d[i] = round(i ** .5, 2)
        print(d[i])

# Подвиг 10. Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программы поступают различные
# URL-адреса. Если адрес пришел впервые, то на экране отобразить строку (без кавычек):"HTML-страница для адреса
# <URL-адрес>"Если адрес приходит повторно, то следует взять строку "HTML-страница для адреса <URL-адрес>"
# из словаря и вывести на экран сообщение (без кавычек):"Взято из кэша: HTML-страница для адреса <URL-адрес>"
# Сообщения выводить каждое с новой строки.

lst_in = ['ustanovka-i-zapusk-yazyka', 'ustanovka-i-poryadok-raboty-pycharm',
          'peremennyye-operator-prisvaivaniya-tipy-dannykh', 'arifmeticheskiye-operatsii',
          'ustanovka-i-poryadok-raboty-pycharm']
print(lst_in)
d = {}
for k in lst_in:
    if k in d:
        print('Взято из кэша:', d[k], k)
    else:
        d[k] = 'HTML-страница для адреса'
        print(d[k], k)

d = {}
for i in lst_in:
    print(f'{d.get(i, "")}HTML-страница для адреса{i}')  # Метод dict.get() возвращает значение для ключа key,
    # если ключ находится в словаре, если ключ отсутствует то вернет значение default.
    d[i] = 'Взято из кэша:'

d = {}
lst = [9, 13, 1, 3, 7, 3, 1, 1, 7, 1, 7, 9]
for i in lst:
    if d.get(i):
        d[i] += 1
    else:
        d[i] = 1
print(d)
rez = sorted(d.items(), key=lambda x: x[1], reverse=True)  # отсортировать словарь
# по значению (количеству появлений элементов в списке)
print(rez)

# Подвиг 3. Вводится строка из русских букв и символов пробела. Необходимо ее закодировать азбукой Морзе, где каждой
# букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять пробел
# (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе
# приведены ниже для русского алфавита и символа пробела:
d = {' ': '-...-', 'Ё': '.', 'А': '.-', 'Б': '-...', 'В': '.--', 'Г': '--.', 'Д': '-..', 'Е': '.', 'Ж': '...-',
     'З': '--..', 'И': '..', 'Й': '.---', 'К': '-.-', 'Л': '.-..', 'М': '--', 'Н': '-.', 'О': '---', 'П': '.--.',
     'Р': '.-.', 'С': '...', 'Т': '-', 'У': '..-', 'Ф': '..-.', 'Х': '....', 'Ц': '-.-.', 'Ч': '---.', 'Ш': '----',
     'Щ': '--.-', 'Ъ': '--.--', 'Ы': '-.--', 'Ь': '-..-', 'Э': '..-..', 'Ю': '..--', 'Я': '.-.-'}
# s=input().upper()
s = 'Сергей Балакирев'.upper()
for i in s:
    if i == s[len(s) - 1]:
        print(d[i], end='')
    print(d[i], end=' ')

s = 'Сергей Балакирев'
print(*[d[i] if i == s[len(s) - 1].upper() else d[i] + ' ' for i in s.upper()])

morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-',
         'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---',
         'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.',
         'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..',
         'ю': '..--', 'я': '.-.-', ' ': '-···-', '@': ' '}
print('@'.join(input().lower()).translate(str.maketrans(morze)))

# Подвиг 4. Имеется закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее
# раскодировать, используя азбуку Морзе из предыдущего занятия. Полученное сообщение (строку) вывести на экран.
cod = '.-- ... . -...- .-- . .-. -. ---'.split()
# cod=input().split()
for i in cod:
    for k, v in d.items():
        if i == v:
            print(k.lower(), end='')

l = [k.lower() for i in cod for k, v in d.items() if i == v]
for i in l:
    print(i, end='')

cod = '.-- ... . -...- .-- . .-. -. ---'
d2 = {v: k for k, v in d.items()}
# print(d2) #поменял местами ключи со значениями
print(*[d2[i].lower() for i in cod.split()], sep='')

d2 = dict(list(map(reversed, d.items())))  # поменял местами ключи со значениями
for i in cod.split():
    print(d2[i].lower(), end='')

print(''.join([dict(map(reversed, d.items()))[i].lower() for i in cod.split()]))

# Подвиг 5. Вводится список целых чисел в одну строчку через пробел. С помощью словаря выделите только уникальные
# (не повторяющиеся) введенные значения и, затем, сформируйте список из уникальных чисел. Выведите его на экран в
# виде набора чисел, записанных через пробел.
# P. S. Такая задача, обычно решается через множества, но мы их еще # не проходили, поэтому воспользуемся словарем.
num = input()
d = {}
for i in num.split():
    d[i] = ''
for i in d:
    print(i, end=' ')

num = '8 11 -4 5 2 11 4 8'
print(*dict.fromkeys(num.split()))

d = dict.fromkeys(num.split())
print(*d.keys())

print(*dict.fromkeys([int(i) for i in num.split()]))

# Подвиг 6. Вводятся данные в формате:<день рождения 1> имя_1<день рождения 2> имя_2...<день рождения N> имя_N
# Дни рождений и имена могут повторяться. На их основе сформировать словарь и вывести его в формате
# (см. пример ниже):день рождения 1: имя1, ..., имяN1день рождения 2: имя1, ..., имяN2...
# день рождения M: имя1, ..., имяNM

import sys

lst_in = list(map(str.strip, sys.stdin.readlines()))
d = {}
for i in lst_in:
    d.setdefault(i.split()[0], []).append(i.split()[1])
for k, v in d.items():
    print(f'{k}: ', end='')
    print(*v, sep=', ')
    # print(k+':',', '.join(v))
    # print(f'{k}: {", ".join(v)}')

for i in lst_in:
    k, v = i.split()
    d[k] = d.get(k, []) + [v]  # в первом аргументе имеет ключ, значение которого он должен вернуть. А вторым
    # (необязательным) аргументом является значение, которое возвратиться в случае отсутствия такого ключа.
    # Таким образом в данной строке он присваивает ключу его же значение, в случае если оно уже есть в словаре
    # (т.е ничего не меняется). Если же его нет, то вместо него возвращается пустой список. А полученный результат
    # (пустой список, либо уже имеющееся значение) обьединяется со списком [value].

for i in lst_in:
    k, v = i.split()
    if k not in d:
        d[k] = [v]
    else:
        d[k] += [v]
for k, v in d.items():
    print(f'{k}: {", ".join(v)}')

# Подвиг 7. Имеется словарь с наименованиями предметов и их весом (в граммах):
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300, 'брюки': 1000, 'бумага': 200,
# 'молоток': 600, 'пила': 400, 'удочка': 1200,'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130,
# 'спички': 10}
# Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг
# (вводится с клавиатуры). Он решил класть в рюкзак предметы в порядке убывания их веса
# (сначала самые тяжелые, затем, все более легкие) так, чтобы их суммарный вес не превысил значения N кг.
# Все предметы даны в единственном экземпляре. Выведите список предметов (в строчку через пробел),
# которые берет с собой Сергей в порядке убывания их веса.  P. S. 1 кг = 1000 грамм

things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
          'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
          'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
p = int(input()) * 1000
un_d = {}
for k, v in things.items():
    un_d[v] = k  # переворачиваем словарь
sort_un_d = sorted(un_d, reverse=True)
s = 0
for i in sort_un_d:
    if (s + i) > p:
        continue
    else:
        s += i
        print(un_d[i], end=' ')

things_sort = {v: k for k, v in things.items()}  # переворачиваем словарь
things_sort = sorted(things_sort.items(), reverse=True)
print(things_sort)  # [(5240, 'палатка'), (2130, 'брезент'), (1200, 'удочка'), (1000, 'брюки'), (820, 'котелок')
for i in things_sort:
    if n - i[0] >= 0:
        print(i[1], end=' ')
        n -= i[0]

d_sort = sorted(things.items(), key=lambda x: -x[1])
d_sort = sorted(things.items(), key=lambda x: x[1], reverse=True)
print(d_sort)
s = 0
for i in d_sort:
    if s + i[1] > p:
        continue
    else:
        s += i[1]
        print(i[0], end=' ')

for i in sorted(things.values(), reverse=True):
    if i <= n:  # n-i>=0:
        for k, v in things.items():
            if v == i:
                print(k, end=' ')
        n -= i

bag = []
[bag.append(i) for i in sorted(things.values(), reverse=True) if sum(bag) + i <= n]
[print(*[[j[0] for j in things.items() if j[1] == i][0] for i in bag])]

######### 6.3 Кортежи (tuple) и их методы
# Подвиг 4. Вводятся названия городов в одну строку через пробел. На их основе формируется кортеж.
# Если в этом кортеже нет города "Москва", то следует его добавить в конец кортежа.
# Результат вывести на экран в виде строки с названиями городов через пробел.

t = tuple(map(str, input().split()))
# t=('Уфа', 'Казань', 'Самара')

if "Москва" not in t:
    t += ("Москва",)
    print(*t)

print(*(t + ("Москва",) if "Москва" not in t else t))

# Подвиг 5. Вводятся названия городов в одну строку через пробел. На их основе формируется кортеж. Если в этом кортеже
# присутствует город "Ульяновск", то этот элемент следует удалить (создав новый кортеж). Результат вывести на экран в
# виде строки с названиями городов через пробел.

# t=tuple(input().split())
# t=('Воронеж', 'Самара', 'Тольятти', 'Ульяновск', 'Пермь')

print(*tuple(city for city in input().split() if city != 'Ульяновск'))

print(*input().replace('Ульяновск', '').split())

t = tuple(filter(lambda x: x != 'Ульяновск', input().split()))
print(*t)

# Подвиг 6. Вводятся имена студентов в одну строчку через пробел. На их основе формируется кортеж. Отобразите на экране
# все имена из этого кортежа, которые содержат фрагмент "ва" (без учета регистра). Имена выводятся в одну строчку через
# пробел в нижнем регистре (малыми буквами).

# t=tuple(input().split())
t = ('Петя', 'Варвара', 'Венера', 'Василиса', 'Василий', 'Федор')
print(*(i.lower() for i in t if "ва" in i.lower()))

print(*tuple(filter(lambda x: "ва" in x, input().lower().split())))

# Подвиг 7. Вводятся целые числа в одну строку через пробел. На их основе формируется кортеж. Необходимо создать
# еще один кортеж с уникальными (не повторяющимися) значениями из первого кортежа. Результат отобразите в виде списка
# чисел через пробел.

# t=tuple(map(int,input().split()))
t = (8, 11, -5, -2, 8, 11, -5)
t1 = tuple()
for i in t:
    if i not in t1:
        t1 += i,
print(*t1)

t = (8, 11, -5, -2, 8, 11, -5)
print(*(dict.fromkeys(t)))

print(*(v for i, v in enumerate(t) if v not in t[:i]))

###Подвиг 8. Вводятся целые числа в одну строку через пробел. На их основе формируется кортеж. Необходимо
# найти и вывести все индексы неуникальных (повторяющихся) значений в этом кортеже. Результат отобразите
# в виде строки чисел, # записанных через пробел.

# t=tuple(map(int,input().split()))
t = (5, 4, -3, 2, 4, 5, 10, 11)
print(*(i for i, v in enumerate(t) if t.count(v) > 1))

for i, v in enumerate(t):
    if t.count(v) > 1:
        print(i, end=' ')

d = {}
for i in t:
    d[i] = d.get(i, 0) + 1
    # d.setdefault(i, []) .append(1)
print(*(i for i, v in enumerate(t) if d[v] > 1))

d = {}
for i in t:
    d.setdefault(i, []).append(1)  # {5: [1, 1], 4: [1, 1], -3: [1], 2: [1], 10: [1], 11: [1]}
print(*(i for i, v in enumerate(t) if len(d[v]) > 1))

print(*(t.index(t[i], i) for i in range(len(t)) if t.count(t[i]) > 1))

t = (5, 4, -3, 2, 4, 5, 10, 11)
t1 = ()
for i, v in enumerate(t):
    if t.count(v) > 1:
        t1 += i,
print(*t1)

# Подвиг 9. Имеется двумерный кортеж, размером 5 x 5 элементов:
# t = ((1, 0, 0, 0, 0),
# (0, 1, 0, 0, 0),
# (0, 0, 1, 0, 0),
# (0, 0, 0, 1, 0),
# (0, 0, 0, 0, 1))
# Вводится натуральное число N (N < 5). Необходимо на основе кортежа t сформировать новый аналогичный кортеж t2
# размером N x N элементов. Результат вывести на экран в виде таблицы чисел.

t = ((1, 0, 0, 0, 0), (0, 1, 0, 0, 0), (0, 0, 1, 0, 0), (0, 0, 0, 1, 0), (0, 0, 0, 0, 1))
# N=int(input())
N = 3
tt = tuple()
for i in range(N):
    t1 = tuple()
    for j in range(N):
        t1 += (t[i][j],)
    tt += tuple(t1),
for i in tt:
    print(*i)

n = 3
t1 = ()
for i in range(n):
    t1 += t[i][:n],

for i in range(n):
    print(*t[i][:n])

[print(*t[i][:n]) for i in range(n)]

for i in t[:n]:
    print(*i[:n])

tt = [[t[i][j] for j in range(n)] for i in range(n)]
[print(*i) for i in tt]

[print(*(t[i][j] for j in range(n))) for i in range(n)]

# Подвиг 10. Вводятся пункты меню (каждый пункт с новой строки) в формате:
# название_1 URL-адрес_1
# название_2 URL-адрес_2
# ...название_N URL-адрес_N
# Необходимо эту информацию представить в виде вложенного кортежа menu в формате:
# ((название_1, URL-адрес_1), (название_2, URL-адрес_2), ... (название_N, URL-адрес_N))
import sys

# lst=tuple(map(str.strip,sys.stdin.readlines()))
lst_in = ('Главная home', 'Python learn-python', 'Java learn-java', 'PHP learn-php')
print(lst)
t = tuple()
for i in lst:
    t += tuple(i.split()),
print(t)

t = (tuple(tuple(i.split()) for i in lst_in))
print(t)

print((*map(tuple, map(str.split, open(0))),))

print((*map(tuple, map(str.split, sys.stdin)),))

###  6.4 Множества (set) и их методы

s = set(map(float, input().split()))
print(*sorted(s))

s = set(input().lower().split())
print(len(s))

# Подвиг 5. Вводится строка, содержащая латинские символы, пробелы и цифры. Необходимо выделить из нее все
# неповторяющиеся цифры (символы от 0 до 9) и вывести на экран в одну строку через пробел их в порядке возрастания
# значений. Если цифры отсутствуют, то вывести слово НЕТ.

lst = list(map(str, input()))
s = set()
for i in lst:
    if i.isdigit():
        s.add(i)
print(*sorted(s) if len(s) > 0 else 'НЕТ')

s = {i for i in input() if i.isdigit()}
print([' '.join(sorted(s)), 'НЕТ'][len(s) == 0])

print(*sorted(set(i for i in input() if i.isdigit())) or ['НЕТ'])

import re

print(*sorted(set(re.findall(r'\d', input()))) or ['НЕТ'])

# Подвиг 6. В ночном клубе фиксируется список гостей. Причем гости могут выходить из помещения, а затем, снова
# заходить. Тогда их имена фиксируются повторно. На вход программы поступает такой список (каждое имя записано с
# новой строки). Требуется подсчитать общее число гостей, которые посетили ночной клуб. Полагается, что гости
# имеют уникальные имена. На экран вывести общее число гостей клуба.

import sys

print(len(set(map(str.strip, sys.stdin.readlines()))))

print(len(set(map(str.strip, open(0)))))

print(len(set(i.strip() for i in open(0))))

# Подвиг 7. В аккаунте youtube Сергея прокомментировали очередное видео. Некоторые посетители оставляли
# несколько комментариев. Требуется по списку комментариев определить уникальное число комментаторов.
# Комментарии поступают на вход программы в формате:

print(len(set(i.split(':')[0] for i in open(0))))

# Подвиг 8. Пользователь с клавиатуры вводит названия городов, пока не введет букву q. Определить общее
# уникальное число городов, которые вводил пользователь. На экран вывести это число. Из коллекций при
# реализации программы использовать только множества.

c = input()
s = set()
while c != 'q':
    s.add(c)
    c = input()
print(len(s))

print(len(set(i for i in iter(input, 'q'))))

print(len(set(iter(input, 'q'))))

# Подвиг 1. Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел). Необходимо
# выбрать и отобразить на экране уникальные числа, присутствующие и в первом и во втором списках одновременно.
# Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел, используя команду
sA = set(map(int, input().split()))  # sA={int(i)for i in input().split()}
sB = set(map(int, input().split()))
print(*sorted(sA & sB))

print(*sorted(set(input().split()) & set(input().split()), key=int))
print(*sorted(map(int, set(input().split()) & set(input().split()))))

l = [map(int, i.split()) for i in open(0).read().split('\n')]
print(*sorted(set(l[0]) & set(l[1])))

# Подвиг 2. Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел).
# Необходимо выбрать и отобразить на экране уникальные числа, присутствующие в первом списке, но отсутствующие во
# втором. Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.
print(*sorted(map(int, (set(input().split()) - set(input().split())))))

print(*sorted((set(input().split()) - set(input().split())), key=int))

print(*sorted(set.difference(*[set(input().split()) for i in '12']), key=int))

a, b = [set(map(int, input().split())) for i in range(2)]
print(*sorted(a - b))

s = [map(int, i.split()) for i in open(0).read().split('\n')]
print(*sorted(set(s[0]) - set(s[1])))

s1 = set(int(x) for x in input().split())
s2 = {int(x) for x in input().split()}
s = s1 - s2
print(*sorted(s))

# Подвиг 3. Вводятся два списка целых чисел каждый с новой строки (в строке наборы чисел через пробел). Необходимо
# выбрать и отобразить на экране уникальные числа, присутствующие в первом или втором списках, но отсутствующие
# одновременно в обоих. Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.

print(*sorted(set(input().split()) ^ set(input().split()), key=int))

a, b = [set(map(int, input().split())) for i in range(2)]
print(*sorted(a ^ b))

# Подвиг 4. Вводятся два списка городов каждый с новой строки (в строке названия через пробел). Необходимо сравнить
# их между собой на равенство по уникальным (не повторяющимся) городам. Если списки содержат одни и те же уникальные
# города, то вывести на экран ДА, иначе - НЕТ.

a, b = [set(map(str, input().split())) for i in range(2)]
if a == b:
    print('ДА')
else:
    print('НЕТ')

print('ДА' if set(input().split()) == set(input().split()) else 'НЕТ')

print(['НЕТ', 'ДА'][set(input().split()) == set(input().split())])

# Подвиг 5. Вводится список оценок студента - его ответов у доски по предмету "Информатика" в виде чисел от 2 до 5 в
# одну строку через пробел. Если студент имеет хотя бы одну двойку, то он не допускается до экзамена. Определить на
# основе введенного списка, допущен ли студент. Если допущен, то вывести слово ДОПУЩЕН, иначе - НЕ ДОПУЩЕН.
# При реализации задачи используйте множество для определения наличия двойки.

print('ДОПУЩЕН' if '2' not in set(input().split()) else ' НЕ ДОПУЩЕН')

print(['НЕ ДОПУЩЕН', 'ДОПУЩЕН']['2' not in set(input().split())])

# Подвиг 6. Вводятся два списка городов каждый с новой строки (в строке названия через пробел), которые объехал
# Сергей в 1-й и 2-й годы своего путешествия по России. Требуется определить, включал ли его маршрут во 2-й год все
# города 1-го года путешествия? Если это так, то вывести ДА, иначе - НЕТ.

print(['НЕТ', 'ДА'][set(input().split()) <= set(input().split())])

##Подвиг 7. Вводится натуральное число, которое может быть определено простыми множителями 1, 2, 3, 5 и 7.
# Необходимо разложить введенное число на указанные простые множители и проверить, содержит ли оно множители 2, 3 и 5
# (все указанные множители)? Если это так, то вывести ДА, иначе - НЕТ.


# Подвиг 2. Вводится строка со списком оценок, например:2 неудовлетворительно удовлетворительно хорошо отлично
# Первая цифра - это числовое значение первой оценки. Остальные оценки имеют возрастающие на 1 числа. С помощью
# генератора словарей необходимо сформировать словарь d, где ключами будут выступать числа, а значениями - слова.
# Например:d = {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо', 5: 'отлично'}
# Вывести на экран значение сформированного словаря с ключом 4.

# s=input().split()
s = ['1', 'ужасно', 'неудовлетворительно', 'удовлетворительно', 'прилично', 'отлично']
n = int(s.pop(0))
d = {n + i: s[i] for i in range(len(s))}
print(d[4])

n = int(s.pop(0))
d = {i: v for i, v in enumerate(s, start=n)}
d = {k: v for k, v in enumerate(s[1:], start=int(s[0]))}
print(d[4])

s = input().split()
n, s = s[0], s[1:]
d = {key: value for key, value in
     enumerate(st, start=int(n))}  # n берёт себе первый аргумент списка, а *st все остальные

n, *s = input().split()
d = {k: v for k, v in enumerate(s, start=int(n))}

start, *names = input().split()
print(dict(enumerate(names, int(start)))[4])

# Подвиг 3. На автомойку в течение квартала заезжали машины. Их гос. номера фиксировались в журнале, следующим
# образом (пример):Е220СКА120МВВ101ААЕ220СКА120МВ
# На основе такого списка через генератор множеств сформировать список уникальных машин. На экран вывести число
# уникальных машин.

s = {i.strip() for i in sys.stdin.readlines()}
print(len(s))

print(len(set(open(0).read().split())))

print(len(set(open(0))))

print(len(set(map(str.strip, open(0)))))

print(len({i.strip() for i in open(0)}))

# Подвиг 4. Вводится текст в одну строчку со словами через пробел. С помощью генератора множеств сформировать
# множество из уникальных слов без учета регистра и длина которых не менее трех символов. Вывести на экран размер
# этого множества.

print(len(set(i for i in input().lower().split() if len(i) > 2)))
# >= 3, если в самом начале курса говорилось, что такой оператор будет работать дольше, чем > 2.

print(len(set(filter(lambda x: len(x) > 2, input().lower().split()))))

# Подвиг 5. Вводится текст в одну строчку со словами через пробел. Используя генераторы множеств и словарей,
# сформировать словарь в формате:{слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}
# То есть, ключами выступают уникальные слова (без учета регистра), а значениями - число их встречаемости в тексте.
# На экран вывести значение словаря для слова (союза) 'и'. Если такого ключа нет, то вывести 0.

l = input().lower().split()
print({i: l.count(i) for i in set(l)}.get('и', 0))

print(input().lower().split().count('и'))

print({x: s.count(x) for s in [input().lower().split()] for x in s}.get('и', 0))

# Подвиг 6. Вводится список книг книжного магазина в формате:<автор 1>:<название 1>...<автор N>:<название N>
# Авторы с названиями могут повторяться. Необходимо, используя генераторы, сформировать словарь с именем d вида:
# {'автор 1': {'название 1', 'название 2', ..., 'название M'}, ..., 'автор K': {'название 1', 'название 2', ...,
# 'название S'}}
# То есть, ключами выступают уникальные авторы, а значениями - множества с уникальными названиями книг
# соответствующего автора.На экран ничего выводить не нужно, только сформировать словарь обязательно с именем
# d - он, далее будет проверяться в тестах

import sys

# lst_in =list(map(str.strip,sys.stdin.readlines()))
lst_in = ['Пушкин: Сказака о рыбаке и рыбке', 'Есенин: Письмо к женщине', 'Тургенев: Муму', 'Пушкин: Евгений Онегин',
          'Есенин: Русь']
l = [i.split(": ") for i in lst_in]
print(l)
d = {}
for i in l:
    if i[0] not in d:
        d[i[0]] = {i[1]}
    else:
        d[i[0]].update({i[1]})

d = dict()
for i in lst_in:
    if i.split(":")[0] not in d:
        d[i.split(":")[0]] = {i.split(":")[1]}
    else:
        d[i.split(":")[0]] |= {i.split(":")[1]}

d = {i.split(": ")[0]: {j.split(": ")[1] for j in lst_in if i.split(": ")[0] == j.split(": ")[0]} for i in lst_in}

l = [i.split(": ") for i in lst_in]
for i in l:
    d.setdefault(i[0], set()).add(i[1])
print(d)

{d.setdefault(i.split(": ")[0], set()).add(i.split(": ")[1]) for i in lst_in}

{d.setdefault(i[0], set()).add(i[1]) for i in [i.split(": ") for i in lst_in]}

for i in lst_in:
    k, v = i.split(': ')
    d.setdefault(k, set()).add(v)

lst = [i.split(': ') for i in lst_in]
d = {}
{d.setdefault(i[0], set()).add(i[1]) for i in lst}
