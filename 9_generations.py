N = 100
lst=list(range(N))
print(lst)
print(lst.__sizeof__()) #840
it=iter(lst)
print(next(it).__sizeof__()) #24 constanta
print(it.__sizeof__()) #32 constanta
g=(i for i in range(100000000000000000000000000000000000))
print(g) #<generator object <genexpr> at 0x0000019BE3E04380>
print(g.__sizeof__()) #184 constanta

print(dir(g)) #имеет методы '__iter__',  '__next__
print(dir(it)) #            '__iter__',  '__next__
print(dir(dir(lst))) #       '__iter__',

#$###################
g=(i for i in range(10000000000)) #время всё равно затрачивает

print(sum(g))
g=(i for i in range(100))
print(max(g))
g=(i for i in range(100))
print(len(g)) #TypeError: object of type 'generator' has no len()
############ 9.1 Выражения-генераторы
# Подвиг 1. Запишите выражение для генератора, который бы возвращал целые числа от 2 до 10 000 с шагом 1
# (то есть, 2, 3, 4, ..., 10 000). Присвойте этот генератор переменной gen.


gen = (int(i) for i in range(2, 10001))
################################################################
# Подвиг 2. На вход программы поступают два целых числа a и b (a < b), записанные в одну строчку через пробел.
# На их основе запишите генератор для формирования квадратов чисел в диапазоне [a; b].# Преобразуйте этот генератор
# в кортеж чисел (без использования операторов циклов) и присвойте эту коллекцию переменной tp.
#a, b = map(int, input().split())
a, b =2,5
tp=tuple(pow(i,2) for i in range(a,b+1))
print(tp)

#Подвиг 3. На вход программы поступают два целых числа a и b (a < b), записанные в одну строчку через пробел.
# Определите генератор, который бы выдавал модули целых чисел из диапазона [a; b]. В цикле выведите первые пять
# значений этого генератора. Каждое значение с новой строки. (Гарантируется, что пять значений имеются).
a, b = map(int, input().split())
abs_gen = (abs(i) for i in range(a, b + 1))

for i in range(5):
    print(next(abs_gen))

[print(next(abs_gen)) for _ in range(5)]
print(*[next(abs_gen) for i in range(5)], sep='\n')
######################
[print(abs(v)) for i, v in enumerate(range(a, b + 1)) if i < 5]

################# Подвиг 6. Вводится целое положительное число a. Необходимо определить генератор, который бы
# возвращал модули чисел в диапазоне [-a; a], а затем еще один, который бы вычислял кубы чисел
# (возведение в степень 3), возвращаемых первым генератором.Вывести в одну строчку через пробел первые четыре значения.
# (Полагается, что генератор выдает, как минимум четыре значения).

a = 3
gen_exp = (abs(i) for i in range(-a, a+1))
gen_cube = (pow(i, 3) for i in gen_exp)
print(*[next(gen_cube) for _ in range(4)], sep=' ') #27 8 1 0

### ##################
a = 3
def dec_gen(func):
    def wrapper(*args, **kwargs):
        gen_cube = (pow(i, 3) for i in func(*args, **kwargs))
        return gen_cube
    return wrapper

@dec_gen
def gen_exp(a):
    gen_m = (abs(i) for i in range(-a, a + 1))
    return gen_m

# var 1
# print(*gen_exp(a)) #27 8 1 0 1 8 27

cub = gen_exp(a)
print(*[next(cub) for _ in range(4)], sep=' ')  # 27 8 1 0

### ##############  ####
a = 3
gen_num = (pow(j, 3) for i in range(-a, a) for j in [abs(i)])

for i, v in enumerate(gen_num):
    print(v,end=' ')
    if i == 3:
        break

for _ in range(4):
    print(*[next(gen_num)],end=' ')

################################
#Подвиг 7. Используя символы малых букв латинского алфавита (строка ascii_lowercase):from string
# import ascii_lowercase запишите генератор, который бы возвращал все сочетания из двух букв латинского
# алфавита. Выведите первые 50 сочетаний на экран в строку через пробел.Например, первые семь начальных
# сочетаний имеют вид: aa ab ac ad ae af ag
from string import ascii_lowercase as al
gen_alphabet = (i + j for i in al for j in al)
print(*[next(gen_alphabet) for _ in range(50)])

[print(next(gen_alphabet), end=' ') for _ in range(50)]
#генератор списков отрабатывает независимо от того присваивается ли его результат переменной или нет. соответственно
# в данном случае для указанного количества итераций в генераторе списков отрабатывает функция принт. ради интереса
# если присвоить значение этого генератора переменной (к примеру - a = [данный генератор]) результат выполнения
# кода будет точно такой же - распечатаются первые 50 пар букв) только если после этого вызвать print(a) то выведет
# сперва так же 50 пар букв, а затем список из 50 значений None т.к. функция принт в генераторе сперва
# выполнится(выведет на экран все значения) и после каждого вывода будет возвращать в генератор None. проще говоря
# при такой записи как в данном решении на экран выводятся не значения самого генератора списков(напомню -
# они все равны None), а результат выполнения функции print() внутри генератора на каждой итерации его работы

### ##################
[print(v, end=' ') for i, v in enumerate(i + j for i in ascii_lowercase for j in ascii_lowercase) if i < 50]


### ##################
lst = list(i + p for i in ascii_lowercase for p in ascii_lowercase)
print(lst[:50])
print(len(lst))  # 676
#только используя данное решение, производится 707 операций, а при использовании выражения-генератора - 207.
# нормальная такая разница, да?) дело в том, что через list comprehension сперва полностью формируется этот список,
# а затем с него берется срез. с этого имеем следующее:  1) куча ненужных вычислений 2) куча засраной памяти т.к.
# полностью формируется никому не нужный список абсолютно всех сочетаний букв. если бы по условию задания требовалось
# генерировать не пары букв, а сочетания по 5 букв и так же вывести первые 50, это решение с треском провалилось бы.

###########
from string import ascii_lowercase
import itertools

letters = itertools.product(ascii_lowercase, repeat=2) #Возвращаемое значение: итератор
#Чтобы вычислить декартово произведение последовательности с самим собой, укажите количество повторений в
# необязательном ключевом аргументе repeat. Например выражение product(A, repeat=4) означает то же самое, что и
# product(A, A, A, A).
#repeat=2 как вложенный цикл for i in ...for j in ...)
for _ in range(50):
    print(''.join(next(letters)), end=' ')


#Подвиг 8. Имеется список из названий городов:cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
# Необходимо записать генератор, который бы используя этот список, выдавал 1 000 000 наименований городов по циклу.
# То есть, дойдя до конца списка, возвращался в начало и повторял перебор. И так, для выдачи миллиона названий.
# Вывести на экран первые 20 наименований городов с помощью генератора в одну строчку через пробел.
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
n = 1000000
gen_cities = (i for _ in range(n) for i in cities) #в генераторе 6 млн сидит
#gen_cities = (i for i in cities*n)
print(*(next(gen_cities) for _ in range(20)), end=' ')

############
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
n = 1000000
gen_cities = (cities[i % len(cities)] for i in range(n))
#Если при вычислении остатка от деления делимое меньше делителя, то частное равняется делимому: 5 % 6 = 5
# А если делимое и делитель равны, то частное 0, ну а потом считается стандартный остаток от деления.
# Так можно перебирать индексы хоть до бесконечности.
print(*(next(gen_cities) for i in range(20)))

#####################
from itertools import cycle
gen = cycle(cities)
[print(next(gen), end = ' ') for _ in range(20)]

##########
from itertools import chain, repeat
c, r = divmod(1_000_000, len(cities))
gen = chain(repeat(cities, c), (lst[i] for i in range(r)))
lst = [next(gen) for _ in range(n)]

### Подвиг 9. Имеется график функции f(x) = 0.5x^2 - 2. Необходимо записать генератор, который бы выдавал значения
# этой функции для аргумента x в диапазоне [a; b] с шагом 0.01. Величины a, b вводятся с клавиатуры в одну строчку
# через пробел как целые числа (a< b). Вывести на экран первые 20 значений функции с точностью до сотых, взятых из
# генератора.P.S. Значения функции вычислять командой:  f(x) = 0.5 * pow(x, 2) - 2.0
a, b = map(int, input().split())
gen_func = (0.5 * pow(i / 100, 2) - 2.0 for i in range(a*100, (b+1) * 100))

#print(*(round(next(gen_func),2) for _ in range(20)) , end=' ')
for i in range(20):
    print(round(next(gen_func),2),end=' ')

########################################################################
gen_func = (round(0.5 * pow(i / 100, 2) - 2.0,2) for i in range(a*100, (b+1) * 100))
print(*(next(gen_func) for _ in range(20)) , end=' ')
################################################################
import numpy
a, b = map(int, input().split())
def f(x):
    return 0.5 * pow(x, 2) - 2.0
gen = (f(x) for x in numpy.arange(a, b + 1, 0.01))
for _ in range(20):
    print(round(next(gen), 2), end=' ')


##################
# Подвиг 1. Вводится натуральное число N. Необходимо определить функцию-генератор с именем get_sum,
# которая бы возвращала текущую сумму чисел последовательности длины N в диапазоне целых чисел [1; N].
# Например:# # - для первого числа 1 сумма равна 1;
# - для второго числа 2 сумма равна 1+2 = 3
# ....# - для N-го числа сумма равна 1+2+...+(N-1)+N
def get_sum(N):
    t = 0
    g = (i for i in range(1, N + 1))
    for i in g:
        t += i
        yield t

N = 5
# print(*get_sum())
print(*tuple(get_sum(N)))
######################
def get_sum(N):
    t = 0
    g = (i for i in range(1, N + 1))
    for i in g:
        yield (t := t + i)
######################
def get_sum(n):
    for i in range(1, n + 1):
        yield i * (i + 1) // 2 #формула подходит только для шага 1 =).
######################
def get_sum(N):
    for i in range(1,N+1):
        yield sum(range(i+1))

#################
#Подвиг 2. Мы с вами в заданиях несколько раз генерировали последовательность чисел Фибоначчи, которая
# строится по правилу: каждое последующее число равно сумме двух предыдущих. Для разнообразия давайте
# будем генерировать каждое последующее как сумму трех предыдущих чисел. При этом первые три числа равны
# 1 и имеем такую последовательность:1, 1, 1, 3, 5, 9, 17, 31, 57, ...Не знаю, есть ли у нее название,
# поэтому, в рамках уроков, я скромно назову ее последовательностью Балакирева. Итак, на вход программы
# поступает натуральное число N (N > 5) и необходимо определить функцию-генератор, которая бы возвращала
# N первых чисел последовательности Балакирева (включая первые три единицы).

N = 7
def get_balakirev():
    lst = [1, 1, 1]
    print(*lst, end=' ')
    for i in range(N - len(lst)):
        total = sum(lst[-3:])
        lst.append(total)
        yield total

print(*get_balakirev())

#################
def get_balakirev():
    # a = b = c = 1
    a,b,c = 1,1,1
    for _ in range(N):
        yield a
        a, b, c = b, c, a+b+c


print(*get_balakirev())
#################
N = 7
def get_balakirev():
    a = b = c = 1
    while True:
        yield a
        a, b, c = b, c, a + b + c

b = get_balakirev()
for i in range(N):
    print(next(b), end=' ')
#- именно через бесконечный цикл. суть задания как раз в том чтобы создать функцию, которая будет
# бесконечно генерировать последовательность, и затем вызвать функцию столько раз, сколько нужно
# получить значений, а не передавать в генератор количество значений которое нужно получить. во всех
# решениях где N передается в функцию, теряется в принципе смысл елдить, оно там ничего не дает и проще
# было реализовать в рекурсии
################# рекурсиями
def gen(N):
    def seq(i):
        return seq(i - 1) + seq(i - 2) + seq(i - 3) if i > 3 else 1

    for i in range(1, N + 1):
        yield seq(i)
print(*gen(N))

#################
#Подвиг 3. Вводится натуральное число N (N > 8). Необходимо определить функцию-генератор, которая бы выдавала пароль
# длиной N символов из случайных букв, цифр и некоторых других знаков. Для получения последовательности допустимых
# символов для генерации паролей в программе импортированы две строки: ascii_lowercase, ascii_uppercase (см. листинг
# ниже), на основе которых формируется общий список:
# from string import ascii_lowercase Строчные буквы 'abcdefghijklmnopqrstuvwxyz',
# ascii_uppercase Прописные буквы 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
# Функция-генератор должна при каждом вызове возвращать новый пароль из случайно выбранных символов chars длиной N
# и делать это бесконечно, то есть, вызывать ее можно бесконечное число раз. Сгенерировать случайный индекс indx в
# диапазоне [a; b] для символа можно с помощью функции randint модуля random:import random
# random.seed(1)indx = random.randint(a, b)Сгенерируйте с помощью этой функции первые пять паролей и выведите их в
# столбик (каждый с новой строки).

import random
from string import ascii_lowercase, ascii_uppercase

chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
print(chars) #abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!?@#$*
# установка зерна датчика случайных чисел (не менять)
random.seed(1) #Функция random.seed() в Python используется для инициализации случайных чисел. По умолчанию генератор
# случайных чисел использует текущее системное время. Если вы дважды используете одно и то же начальное значение,
# вы получите один и тот же результат, что означает случайное число дважды (с)
#достаточно запомнить какое-то своё любимое число, которое будет ключом в seed() и всегда можно получить свой
# какой-угодно сложный пароль.
# password ='pavel'
# random.seed('pavel')
#то псевдо рандом)) он всегда с чего то генерирует число по какому то алгоритму, и метод seed как раз задает
# отправную точку) поэтому и получается каждый раз одно и то же.
N = 10
def gen_pass():
    while True:
        w = ''
        for i in range(N):
            indx = random.randint(0,len(chars)-1) #randint – включает правую границу
            # randint(a, b) берёт числа из диапазона включительно [a, b].
            w += chars[indx]
            yield w

pas = gen_pass()
for _ in range(5):
    print(next(pas))
#################
# from random import  choice, seed #v2
import random
from string import ascii_lowercase, ascii_uppercase
random.seed(1)
# seed(1) v 2
chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
N = 10
def gen_pass():
    while True:
        yield ''.join(random.choice(chars) for _ in range(N)) #возвращает один случайный элемент из непустой последови

pas = gen_pass()
for _ in range(5):
    print(next(pas))
################################
    def gen_pass():
        for _ in range(N):
            yield random.choice(chars)

for _ in range(5):
    print(''.join(gen_pass())) #в join можно подать любую последовательность (включая генератор).
################################

#Подвиг 4. Вводится натуральное число N. Используя строки из латинских букв ascii_lowercase и ascii_uppercase:
# from string import ascii_lowercase, ascii_uppercase
# chars = ascii_lowercase + ascii_uppercase
# задайте функцию-генератор, которая бы возвращала случайно сформированные email-адреса с доменом mail.ru и
# длиной в N символов. Например, при N=6, получим адрес: SCrUZo@mail.ru
# Для формирования случайного индекса для строки chars используйте функцию randint модуля random:
# Функция-генератор должна возвращать бесконечное число таких адресов, то есть, генерировать постоянно.
# Выведите первые пять сгенерированных email и выведите их в столбик (каждый с новой строки).
from string import ascii_lowercase, ascii_uppercase
import random
chars = ascii_lowercase + ascii_uppercase
#print(chars) #abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
random.seed(1)
N = 8
def gen_mail():
    while True:
        w = ''
        for i in range(N):
            indx = random.randint(0, len(chars) - 1)
            w += chars[indx]
        yield w + '@mail.ru'

g = gen_mail()
for _ in range(5):
    print(next(g))
#################
#Подвиг 5. Определите функцию-генератор, которая бы возвращала простые числа. (Простое число - это натуральное число,
# которое делится только на себя и на 1). Выведите с помощью этой функции первые 20 простых чисел (начиная с 2)
# в одну строчку через пробел.
################################
def gen_num():
    n = 1
    while True: #бесконечный цикл можно открыть с помомшью конструкции while True:
        n += 1
        if all(n % i for i in range(2, int(n**0.5)+1)): #n ** 0.5 это квадратный корень, предельное число,
    # после которого можно прерывать цикл range(2, limit) выдает последовательность n % i - остатки от деления нацело
    # all - даст True только если интерпретирует все элементы как True, в данном случае, все ненулевые,
    # то есть, не делящиеся нацело  Если хоть одно число делится, результат будет False
            yield n

num = gen_num() # !!!Нужно сначала создать объект, присвоить ему значение генератора и итерироваться уже объекту,
# а не по самой функции.
print(next(gen_num())) # функция-генератор инициализируется 1 раз
print(next(gen_num())) # выдаёт каждый раз при вызове 2 Если так вызывать, то это каждый раз новый генератор
for i in range(20):
    print(next(num), end=' ') # функция-генератор инициализируется 20 (на каждой итерации)
    #видимо пока у нас нет ссылки на генератор, он удаляется, и при следующем вызове функции, создаётся новый с
    # двойкой по умолчанию, который отработав удаляется т.к. у нас же на него нет ссылки :).
################################
def gen_num():
    n = 2
    yield n
    while True:
        n += 1
        for i in range(2, n):
            if n % i == 0:
                break
        else: #если число на что-то поделилось нацело - срабатывает break и блок else пропускается, если же делителей
            # не нашлось - цикл завершится и else вернет число.
            yield n

num = gen_num()
for i in range(20):
    print(next(num), end=' ')
#################
def gen_num():
    n = 1
    while True:
        n += 1
        if not any(n % i == 0 for i in range(2, n)):
            yield n
#################
def gen_num():
    n = 1
    while True:
        n += 1
        if all(n % i for i in range(2, n)):
            yield n
#################
from sympy import prime

def gen_num():
    n = 1
    while True:
        yield prime(n) #sympy.prime(), n  здесь это просто номер простого числа,
        n += 1
#################
def is_prime(n): #Решил разбить задачу на две функции: функцию-предикат (определяет является ли число простым) и
    # функцию-генератор.
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def gen_num():
    n = 2
    while True:
        if is_prime(n):
            yield n
        n += 1

#################
import re

def isprime(n):
    return re.compile(r'^1?$|^(11+)\1+$').match('1' * n) is None

print(*[x for x in range(100) if isprime(x)][:20])
#################
#################    9.3 Функция map
#Подвиг 1. На вход поступает список из вещественных чисел, записанных в строку через пробел. С помощью функции map
# преобразовать числа в строке в их вещественное представление и отобразить первые три числа. (Полагается, что
# минимум три вещественных числа имеются). Реализовать извлечение чисел через функцию next. Результат отобразить в
print(*[*map(float,input().split())][:3])
#################
m = map(float, input().split())
print(*(next(m) for _ in range(3)))
################
#Подвиг 2. На вход поступает строка из целых чисел, записанных через пробел. С помощью функции map преобразовать
# эту строку в список целых чисел, взятых по модулю. Сформируйте именно список lst из таких чисел. Отобразите его
# на экране в виде набора чисел, идущих через пробел.
lst = list( map( abs,  map(int, input().split())))
print(*lst)
#################
lst = list(map(lambda x: abs(int(x)), input().split()))
print(*lst)
#################
#Подвиг 3. Вводится таблица целых чисел. Используя функцию map и генератор списков, преобразуйте список строк lst_in
# (см. листинг) в двумерный список с именем lst2D, содержащий целые числа.
#################
import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
# lst2D = [*map(lambda x: [*map(int, x.split())], lst_in)] #две map()
# lst2D = list(map(lambda x: [*map(int, x.split())], lst_in)) #две map()
lst2D = [[int(i) for i in x.split()] for x in lst_in] #два генератора
# lst2D = [*map(lambda x: [int(i) for i in x.split()], lst_in)] #генератор в map() и map в генераторе
# lst2D = [[*map(int, x.split())] for x in lst_in] # map()  в генераторе
# lst2D = list(list(map(int, i.split())) for i in lst_in) # map()  в генераторе
print(lst2D)
###############################
#Подвиг 4. На вход программы поступает строка в формате:ключ_1=значение_1 ключ_2=значение_2 ... ключ_N=значение_N
# Необходимо с помощью функции map преобразовать ее в кортеж tp вида:
# tp = (('ключ_1', 'значение_1'), ('ключ_2', 'значение_2'), ..., ('ключ_N', 'значение_N'))
# s_lst = s.split()
# print(s_lst)  # ['house=дом', 'car=машина', 'men=человек', 'tree=дерево']
s_lst = ['house=дом', 'car=машина', 'men=человек', 'tree=дерево']
tp = tuple((i.split('=')[0], i.split('=')[1]) for i in s_lst)
print(tp)  #
#################
tp = tuple((j[0], j[1]) for i in s_lst for j in [i.split('=')])
#################
tp = tuple(map(lambda x: (x.split('=')[0], x.split('=')[1]), s_lst))
#################
tp = tuple(map(lambda x: tuple(x.split('=')), s_lst))
##################################
tp = tuple(map(tuple, [i.split('=') for i in s_lst]))
##################################
tp = tuple(map(tuple, (i.split('=') for i in s_lst)))
##################################
#Подвиг 5. (Для учебных целей). Вводится строка. Необходимо в ней заменить кириллические символы на соответствующие
# латинские обозначения (без учета регистра букв), а все остальные символы - на символ дефиса (-). Для этого в
# программе определен словарь (см. листинг). Используя его, запишите функцию map, которая бы выдавала
# преобразованные фрагменты для входной строки. На основе этой функции сформируйте строку, состоящую из
# преобразованных фрагментов (фрагменты в строке должны идти друг за другом без пробелов).
t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

s = 'Привет Питон'
string = ''.join(map(str, (t[i] if i in t else '-' for i in s.lower())))
print(string) #privet-piton
##################################
string = ''.join(t[i] if i in t else '-' for i in s.lower())
##################################
string = ''.join(map(lambda x: t.get(x, '-'),  s.lower()))
##################################
string = ''.join(map(lambda x: t.setdefault(x, '-'), s.lower()))
##################################
string = ''.join(map(lambda x: t[x] if x in t else '-',  s.lower()))
##################################
#Подвиг 6. Вводятся названия городов в одну строчку через пробел. Необходимо определить функцию map, которая бы
# возвращала названия городов только длиной более 5 символов. Вместо остальных названий - строку с дефисом ("-").
# Сформировать список из полученных значений и отобразить его на экране в одну строчку через пробел.
s = 'Москва Уфа Вологда Тула Владивосток Хабаровск'
string = ' '.join(map(lambda x: x if len(x) > 5 else '-', s.split()))
print(string)
##################################
def string_def(x):
    return x if len(x) > 5 else '-'

string = ' '.join(map(string_def, s.split()))
print(string)


##################################  9.4 Функция filter #######
#алгоритма проверки числа на простоту
def is_prime(n):
    if n <= 1:
        return False
    d = 2
    # while d * d <= n: #свойство p^2 = n. p = n^(1/2)
    while d < n:
        if n % d == 0 or n % 2 == 0:
            return False
        d += 1
    return True

num = filter(is_prime, (i for i in range(30)))
print(*num) #2 3 5 7 11 13 17 19 23 29
print(list(num)) #[]
##################################
#Подвиг 1. Вводятся названия городов в одну строчку через пробел. Необходимо определить функцию
# filter, которая бы возвращала только названия длиной более 5 символов. Извлеките первые
# три полученных значения с помощью функции next и отобразите их на экране в одну строчку
# через пробел.
s = 'Тула Ульяновск Хабаровск Владивосток Омск Уфа'
city = filter(lambda x: len(x) > 5, s.split())

for i in range(3):
    print(next(city),end=' ')
# [print(*city, end='') for _ in range(3)]
# print(*(next(city) for i in range(3)))
##################################
#Подвиг 2. Вводится список предметов в виде списка:название_1: вес_1название_N: вес_NС помощью функции map,
# необходимо сначала преобразовать этот список строк в кортеж, элементами которого также являются кортежи:
# (('название_1', 'вес_1'), ..., ('название_N', 'вес_N'))А, затем, отфильтровать (исключить) все предметы с
# весом менее 500, используя функцию filter. Вывести на экран список оставшихся предметов (только их названия)
# в одну строчку через пробел.
import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
def ress(n):
    # print(n)
    if int(n[1]) >= 500:
        return True
    else:
        return False
# print(lst_in)  # ['зонт=1000', 'палатка=10000', 'спички=22', 'котелок=543']
tp = tuple(map(lambda x: tuple(x.split('=')), lst_in))
# print(tp)  # (('зонт', '1000'), ('палатка', '10000'), ('спички', '22'), ('котелок', '543'))
res = list(filter(ress, (i for i in tp)))

print(*(i[0] for i in res), end=' ') #зонт палатка котелок
# for i in res:
#     print(i[0])
##################################
res = list(filter(lambda x:  int(x[1]) >= 500, (i for i in tp))) #filter фильтрует (отбирает) вложенные кортежи
# согласно условию, а не изменяет их. Вот вы и получили все вложенные кортежи прошедшие условие вашей фильтрации.
# Вы путаете механизмы действия функций map и filter
print(*(i[0] for i in res), end=' ')  # зонт палатка котелок
##################################
lst_in = list(map(str.strip, sys.stdin.readlines()))
tp = tuple(map(lambda x: tuple(x.split('=')), lst_in))
res = filter(lambda x: int(x[1]) >= 500, tp)
g = map(lambda x: x[0], res)
print(*g)
##################################
#Подвиг 3. Вводится список целых чисел в одну строчку через пробел. Необходимо оставить в нем только
# двузначные числа. Реализовать программу с использованием функции filter. Результат отобразить на экране
# в виде последовательности оставшихся чисел в одну строчку через пробел.
# n = ['8', '11', '0', '-23', '140', '1']
res = filter(lambda x: len(str(abs(int(x)))) == 2, n)
print(*res)
##################################
n = '8 11 0 -23 140 1'
res = filter(lambda x: 9 < (abs(int(x))) < 100, n.split())
print(*res)
##################################
res = filter(lambda x: len(x.strip('-'))==2, n.split())
##################################
res = filter(lambda x: len(x.replace('-','')) == 2, n.split())
##################################
#Подвиг 4. Саша и Галя коллекционируют монетки. Каждый из них решил записать номиналы монеток из своей
# коллекции. Получилось два списка. Эти списки поступают на вход программы в виде двух строк из целых чисел,
# записанных через пробел. Необходимо выделить значения, присутствующие в обоих списках и оставить среди них
# только четные. Результат вывести на экран в виде строки полученных чисел в порядке их возрастания через
# пробел.
l1 = '1 5 2 7 10 25 50 100'
l2 = '5 2 3 7 10 25 55'
lst = sorted(filter(lambda x: x in l2 and int(x) % 2 == 0, l1.split()), reverse=True)
print(*lst)
##################################
lst = filter(lambda x: int(x) % 2 == 0, sorted(set(l1.split()) & set(l2.split()),reverse=True))
print(*lst)
##################################
lst = filter(lambda x: not int(x)%2, set(l1.split()) & set(l2.split()))
##################################
#Подвиг 5. Вводится список email-адресов в одну строчку через пробел. Среди них нужно оставить только
# корректно записанные адреса. Будем полагать, что к таким относятся те, что используют латинские буквы,
# цифры и символ подчеркивания. А также в адресе должен быть символ "@", а после него символ точки "."
# (между ними, конечно же, могут быть и другие символы).Результат отобразить в виде строки email-адресов,
# записанных через пробел.
# Sample Input:abc@it.ru dfd3.ru@mail biba123@list.ru sc_lib@list.ru $fg9@fd.com
import string
symbols = string.ascii_lowercase+ string.digits+'_'+'@.'
s=input().lower()
# ad = filter(lambda x: x.isalnum(), s.split()) isalnum() не подходит, поскольку этот метод проускает кирилличные буквы
ad = filter(lambda x: '.' in x.split('@')[1] and all(i in symbols for i in x), s.split())
print(*ad)
##################################
ad = filter(lambda x: x.find('@') < x.find('.') and all(i in symbols for i in x), s.split())
##################################
#9.5 Функция zip
#Подвиг 1. Вводятся два списка целых чисел. Необходимо попарно перебрать их элементы и перемножить между собой. При
# реализации программы используйте функции zip и map. Выведите на экран первые три значения, используя функцию next.
# Значения выводятся в строчку через пробел.
lst_1 = '-7 8 11 -1 3'.split()
lst_2 = '1 2 3 4 5 6 7 8 9 10'.split()

lst_1=input().split()
lst_2=input().split()
result = map(lambda x: int(x[0]) * int(x[1]), zip(lst_1, lst_2))
for i in range(3):
    print(next(result), end=' ')

##################################
#Подвиг 2. Вводится неравномерная таблица целых чисел. С помощью функции zip выровнить эту таблицу, приведя ее к
# прямоугольному виду, отбросив выходящие элементы. Вывести результат на экран в виде такой же таблицы чисел.
import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
tr = zip(*lst_in)
res = zip(*tr)
for i in res:
    print(*i, sep='')

##################################
for i in zip(*zip(*lst_in)):
    print(*i, sep='')
##################################
#Подвиг 3. Вводится таблица целых чисел. Необходимо сначала эту таблицу представить
# двумерным списком чисел, а затем, с помощью функции zip выполнить транспонирование этой
# таблицы (то есть, строки заменить на соответствующие столбцы). Результат вывести на экран
# в виде таблицы чисел
lst_in = list(map(str.strip, sys.stdin.readlines()))
lst_in = ['1 2 3 4', '5 6 7 8', '9 8 7 6']
lst = list(map(int, i.split()) for i in lst_in)
for i in zip(*lst):
    print(*i)
##################################
#Подвиг 4. Вводится строка из слов, записанных через пробел. Необходимо на их основе
# составить прямоугольную таблицу из трех столбцов и N строк (число строк столько, сколько
# получится). Лишнее (выходящее) слово - отбросить.
s='Москва Уфа Тула Самара Омск Воронеж Владивосток Лондон Калининград Севастополь'.split()
lst=[]
k=0
for i in range(3):
    lst.append(list(s[k:k+3]))
    k+=3
[print(*i) for i in lst]
##################################
s = 'Москва Уфа Тула Самара Омск Воронеж Владивосток Лондон Калининград Севастополь'.split()
it = iter(s)
print(*zip(it, it, it)) #('Москва', 'Уфа', 'Тула') ('Самара', 'Омск', 'Воронеж') ('Владивосток', 'Лондон', 'Калининград'
##################################
x = iter([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(*zip(x, x, x)) #(1, 2, 3) (4, 5, 6) (7, 8, 9)
##################################
print(*zip(*[iter(s)]*3))
##################################
#Подвиг 5. Вводится строка. Требуется, используя введенную строку, сформировать N=10 пар кортежей в
# формате:(символ, порядковый индекс)Первый индекс имеет значение 0. Строка может быть короче
# 10 символов, а может быть и длиннее. То есть, число пар может быть 10 и менее. Используя функцию
# zip сформируйте указанные кортежи и сохраните в список с именем lst.
s = 'Python дай мне силы пройти этот курс до конца!'
N = 10
lst = list(zip(s, range(N)))
################################## 9.6 Сортировка с помощью sort и sorted
s = '-2 -1 8 11 4 5 '
lst = list(map(int, s.split()))
tp = tuple(lst)
lst.sort()
tp_lst = tuple(sorted(tp))

##################################
s = '-2 -1 8 11 4 5 '
def get_sort(x):
    try:
        x.sort()
        return x
    except AttributeError:
        return type(x)(sorted(x)) #приведение результата сортировки sorted(x) к типу, определенному через type(x)

lst = list(map(int, s.split()))
tp_lst = tuple(map(int, s.split()))

lst = get_sort(lst)
tp_lst = get_sort(tp_lst)
##################################
#Подвиг 3. На вход функции с именем get_sort поступает словарь, например, такой:Необходимо отсортировать словарь
# d по убыванию ключей (лексикографическая сортировка строк) и возвратить список из соответствующих значений ключей
# словаря. Например, для указанного словаря d, результатом должен быть список:
d = {'cat': 'кот', 'horse': 'лошадь', 'tree': 'дерево', 'dog': 'собака', 'book': 'книга'}
def get_sort(d):
    d = sorted(d.items(), reverse=True)
    #[('tree', 'дерево'), ('horse', 'лошадь'), ('dog', 'собака'), ('cat', 'кот'), ('book', 'книга')]
    return list(dict(d).values())

d_sort = get_sort(d)
print(d_sort) #['дерево', 'лошадь', 'собака', 'кот', 'книга']
##################################
def get_sort(d):
    d = dict(sorted(d.items(), reverse=True))
    return list(d[v] for v in d)
##################################
def get_sort(d):
    return list(d[v] for v in sorted(d, reverse=True))
##################################
def get_sort(d):
    return list(map(lambda x: x[1], sorted(d.items(), reverse=True)))
    #[('tree', 'дерево'), ('horse', 'лошадь'), ('dog', 'собака'), ('cat', 'кот'), ('book', 'книга')]
##################################
def get_sort(d):
    return [val for key, val in sorted(d.items(), reverse=True)]
##################################
#Подвиг 4. На вход программы поступает список целых чисел, записанных в одну строчку через пробел. Необходимо выбрать
# из них четыре наибольших уникальных значения. Результат вывести на экран в порядке их убывания в одну строчку
# через пробел.
s = '10 5 4 -3 2 0 5 10 3'
s=input()
it = iter(sorted(set(map(int, s.split())), reverse=True))
for i in range(4):
    print(next(it), end=' ')
##################################
lst = list(sorted(set(map(int, s.split())), reverse=True))[:4]
##################################
#Подвиг 5. На вход программы поступают два списка целых чисел (каждый в отдельной строке), записанных в одну строчку
# через пробел. Длины списков могут быть разными. Необходимо первый список отсортировать по возрастанию, а второй -
# по убыванию. Полученные пары из обоих списков сложить друг с другом и получить новый список чисел.
l1 = '7 6 4 2 6 7 9 10 4'
l2 = '-4 5 10 4 5 65'
l1 = sorted(list(map(int, l1.split())))
l2 = sorted(list(map(int, l2.split())), reverse=True)
result = list(map(lambda x: x[0] + x[1], zip(l1, l2)))
print(*result)
##################################
result = list(map(sum, zip(l1, l2)))
##################################
#Подвиг 6. На вход программы поступает список товаров в формате:название_1:цена_1...название_N:цена_N
# Необходимо преобразовать этот список в словарь, ключами которого выступают цены (целые числа), а значениями -
# соответствующие названия товаров. Необходимо написать функцию, которая бы принимала на входе словарь и возвращала
# список из наименований трех наиболее дешевых товаров.Вызовите эту функцию и отобразите на экране полученный список
# в порядке возрастания цены в одну строчку через пробел.
import sys
def get_dict(d):
    return map(lambda x: x[1], sorted(d.items())[:3])

lst_in = list(map(str.strip, sys.stdin.readlines()))
# lst_in = ['смартфон:120000', 'яблоко:2', 'сумка:560', 'брюки:2500', 'линейка:10', 'бумага:500']
d = {int(i.split(':')[1]): i.split(':')[0] for i in lst_in}

res = get_dict(d)
print(*res)

################################## 9.7 Аргумент key для сортировки по ключу
#Подвиг 1. На вход программы поступает список наименований рек, записанных в одну строчку через пробел. Необходимо
# отсортировать этот список в порядке убывания длин названий. Результат вывести в одну строчку через пробел.
s=input().split()
print(*sorted(s, key=len, reverse=True))
##################################
#Подвиг 2. На вход программы поступает строка в формате:предмет_1=вес_1...предмет_N=вес_NВеса предметов заданы целыми
# числами. Необходимо на основе этих данных сформировать словарь и, затем, на основе этого словаря сформировать список
# предметов по убыванию их веса. (В списке должны находиться только наименования предметов без их весов).
import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
d = {int(v): k for k, v in (i.split('=') for i in lst_in)}
for i in sorted(d.items(), key=lambda x: x[0], reverse=True):
    print(i[1], end=' ')
########################################################################
lst_in = ['ножницы=100', 'котелок=500', 'спички=20', 'зажигалка=40', 'зеркальце=50']
d = {k: int(v) for k, v in (i.split('=') for i in lst_in)}  #
# print(d) #{'ножницы': 100, 'котелок': 500, 'спички': 20, 'зажигалка': 40, 'зеркальце': 50}
print(sorted(d, key=lambda x: d[x], reverse=True))
##################################
print(*sorted(d, key=lambda x: -d[x]))
#если взять веса с отрицательным знаком, то их порядок поменяется на противоположный, самый большой вес станет
# самым малым и наоборот. Таким образом, ключи словаря отсортируются по убыванию их весов. Параметр key задает функцию,
# с помощью которой будут вычислятся значения для сравения элементов словаря между собой во время сортировки, при этом
# сами ключи и соотвествующие им значения в словаре останутся без изменения.

################################
#Подвиг 3. Известно, что порядок нот, следующий: до, ре, ми, фа, соль, ля, си. На вход программы поступает строка с
# набором этих нот, записанных через пробел. Необходимо сформировать список из входной строки с нотами,
# отсортированными указанным образом. Результат вывести в виде строки из нот, записанными через пробел.Sample Input:
# до фа соль до ре фа ля си
s=input()
example = 'до ре ми фа соль ля си'
d = {}
for i in example.split():
    d.setdefault(i, [])

for i in s.split():
    d[i]. append(i)
s = []
for i in d.values():
    s += i
print(*s)
##################################
example = 'до ре ми фа соль ля си'
s = 'до фа соль до ре фа ля си'
l = sorted(s.split(), key=lambda x: example.find(x))
print(*l)
##################################
print(* sorted(s.split(), key=example.find))
##################################
notes = ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си')
print(*sorted(input().split(), key=notes.index))
################################
notes = dict(zip('до ре ми фа соль ля си'.split(), range(7)))
print(*sorted(input().split(), key=notes.get))
##################################
from time import time
notes_for_test = ['до', 'фа', 'соль', 'до', 'ре', 'фа',
                  'ля', 'си', 'до', 'фа', 'соль', 'до',
                  'ре', 'фа', 'ля', 'си', 'до', 'фа', 'соль',
                  'до', 'ре', 'фа', 'ля', 'си', 'до', 'фа',
                  'соль', 'до', 'ре', 'фа', 'ля', 'си', 'до',
                  'фа', 'соль', 'до', 'ре', 'фа', 'ля', 'си']
# через кортеж
notes = ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си')
beg = time()
for i in range(200_000):
    test = sorted(notes_for_test, key=notes.index)

end = time()
print(end - beg)

# через словарь
notes = dict(zip('до ре ми фа соль ля си'.split(), range(7)))
beg1 = time()
for x in range(200_000):
    test = sorted(notes_for_test, key=notes.get)

end1 = time()
print(end1 - beg1)

# через строку
s = 'до, ре, ми, фа, соль, ля, си'
beg2 = time()
for i in range(200_000):
    test = sorted(notes_for_test, key=s.find)

end2 = time()
print(end2 - beg2)
#Total - 1 - через кортеж, 2 - через словарь, 3 - данное решение через строку.
################################

#Значимый подвиг 4. Имеется таблица с данными, представленная в формате:Номер;Имя;Оценка;Зачет1;Иванов;3;Да2;Петров;
# 2;Нет...N;Балакирев;4;ДаЭти данные необходимо представить в виде двумерного (вложенного) кортежа.
# Все числа должны быть представлены как целые числа. Затем, отсортировать данные так, чтобы столбцы шли в порядке:
# Имя;Зачет;Оценка;Номер
import sys
lst_in = list(map(str.strip, sys.stdin.readlines()))
persons = []
for index, person in enumerate(lst_in):
    number, name, mark, credit = person.split(';')
    if index == 0:  # в первой строке списка lst_in нету чисел
        person_data = (name, credit, mark, number)
    else:  # во всех остальных строках числа срокового типа переводим в целые
        person_data = (name, credit, int(mark), int(number))
    persons.append(person_data)

# print(tuple(persons)) -> (('Имя', 'Зачет', 'Оценка', 'Номер'), ('Портос', 'Да', 5, 1), ('Арамис', 'Да', 3, 2), ('Атос', 'Да', 4, 3),
# ("д'Артаньян", 'Нет', 2, 4), ('Балакирев', 'Нет', 1, 5))
t_sorted = tuple(persons)  # даже и не знаю зачем усложнять решение, используя сортировку?
##################################
lst_in = ['Номер;Имя;Оценка;Зачет', '1;Портос;5;Да', '2;Арамис;3;Да', '3;Атос;4;Да', "4;д'Артаньян;2;Нет",
          '5;Балакирев;1;Нет']
# таблица на выводе должна быть такой:
# (('Имя', 'Зачет', 'Оценка', 'Номер'), ('Портос', 'Да', 5, 1), ('Арамис', 'Да', 3, 2), ('Атос', 'Да', 4, 3),
# ("д'Артаньян", 'Нет', 2, 4), ('Балакирев', 'Нет', 1, 5))

# example=  Имя;Зачет;Оценка;Номер
order = "Имя;Зачет;Оценка;Номер"
t = tuple(tuple(int(st) if st.isdigit() else st for st in row.split(";")) for row in lst_in)
#(('Номер', 'Имя', 'Оценка', 'Зачет'), (1, 'Портос', 5, 'Да'), (2, 'Арамис', 3, 'Да'), (3, 'Атос', 4, 'Да'),
# (4, "д'Артаньян", 2, 'Нет'), (5, 'Балакирев', 1, 'Нет'))
t_sorted = tuple(zip(*sorted(zip(*t), key=lambda x: order.find(x[0]))))
print(t_sorted)
#(('Имя', 'Зачет', 'Оценка', 'Номер'), ('Портос', 'Да', 5, 1), ('Арамис', 'Да', 3, 2), ('Атос', 'Да', 4, 3),
# ("д'Артаньян", 'Нет', 2, 4), ('Балакирев', 'Нет', 1, 5))

#!!!!!Не очень понял предыдущие объяснения по строке key=lambda x: order.find(x[0]). Решил еще раз разобрать пошагово
# сам.1) lambda x - кортежи танспонированной матрицы:
# ('Номер', 1, 2, 3, 4, 5), ('Имя', 'Портос', 'Арамис', 'Атос', "д'Артаньян", 'Балакирев'), ('Оценка', 5, 3, 4, 2, 1),
# ('Зачет', 'Да', 'Да', 'Да', 'Нет', 'Нет')
# 2) order - "Имя;Зачет;Оценка;Номер"
# 3) order.find() -  в строке order найти и вернуть индекс подстроки
# 4) order.find(x[0]) -  в строке order найти и вернуть индексы подстрок: 'Номер', 'Имя', 'Оценка', 'Зачет'.Так, что:
# "Номер" = 3, "Имя" = 0, "Оценка" = 2, "Зачет" = 1
# 5) key=lambda x: order.find(x[0])- сортировать кортежи из пункта 1) в соответствии с индексами первых элементов.
# Т.е. сначала кортеж с Именем (0), потом с Зачетом (1), затем с Оценкой (2) и Номером (3).
#Видим что в транспонированной матрице все заголовки исходной матрицы собрались в первом (нулевом по индексу) столбце.
# Получается что если обозначить через x произвольную строку транспанированной матрицы, то x[0] будет ссылаться на
# соотвествующий заголовок. Строка "Имя;Зачет;Оценка;Номер" по сути задает порядок следования заголовков, чем дальше
# заголовок в строке, тем больше будет значение его позиции в ней, возвращаемой функцией find(x[0]).
#латой за эту универсальность будет вычислительная сложность O(n*m + m\log{m})O(n∗m+mlogm) для таблицы размерностью
# n x m (трансформация с помощью функции zip + сортировка по заголовкам столбцов).
##################################
lst_in = ['Номер;Имя;Оценка;Зачет', '1;Портос;5;Да', '2;Арамис;3;Да', '3;Атос;4;Да', "4;д'Артаньян;2;Нет",
          '5;Балакирев;1;Нет']
# таблица на выводе должна быть такой:
# (('Имя', 'Зачет', 'Оценка', 'Номер'), ('Портос', 'Да', 5, 1), ('Арамис', 'Да', 3, 2), ('Атос', 'Да', 4, 3),
# ("д'Артаньян", 'Нет', 2, 4), ('Балакирев', 'Нет', 1, 5))

t = tuple(tuple(int(j) if j.isdigit() else j for j in i.split(';')) for i in lst_in)
t_z = zip(*t)
# print(*t_z) #
# ('Номер', 1, 2, 3, 4, 5) ('Имя', 'Портос', 'Арамис', 'Атос', "д'Артаньян", 'Балакирев') ('Оценка', 5, 3, 4, 2, 1) ('Зачет', 'Да', 'Да', 'Да', 'Нет', 'Нет')
order = 'Имя;Зачет;Оценка;Номер'
t_sorted = zip(*sorted(t_z, key=lambda x: order.find(x[0])))
print(*t_sorted)
##################################
t_sorted = tuple([
    (name, passed, int(mark) if mark.isdigit() else mark, int(num) if num.isdigit() else num)
    for num, name, mark, passed in [el.split(';') for el in lst_in]])
##################################
lst1 = list((b, d, int(c), int(a)) for a, b, c, d in (line.split(';') for line in lst_in[1:]))
a, b, c, d = lst_in[0].split(';')
print(a, b, c, d) #Номер Имя Оценка Зачет
lst1.insert(0, (b, d, c, a))
t_sorted = tuple(lst1)
##################################
t = tuple([tuple(map(lambda x: int(x) if x in "0123456789" else x, x.split(";"))) for x in lst_in])
t_sorted = tuple([(x[1], x[3], x[2], x[0]) for x in t])
##################################
#Подвиг 5. Известно, что звания военнослужащих имеют следующий порядок:рядовой, сержант, старшина, прапорщик,
# лейтенант, капитан, майор, подполковник, полковник На вход поступает список военнослужащих в формате:
# имя_1=звание_1..имя_N=звание_NНеобходимо входные данные представить в виде вложенного списка вида:
# [['имя_1', 'звание_1'], ['имя_2', 'звание_2'], ..., ['имя_N', 'звание_N']]
# Этот список присвоить переменной с именем lst. Затем, отсортировать его по возрастанию званий.

# import sys
# lst_in =list(map(str.strip,sys.stdin.readlines()))
lst_in = ['Атос=лейтенант', 'Портос=прапорщик', "д'Артаньян=капитан", 'Арамис=лейтенант', 'Балакирев=рядовой']
lst = list(i.split('=') for i in lst_in)
# lst=[['Атос', 'лейтенант'], ['Портос', 'прапорщик'], ["д'Артаньян", 'капитан'], ['Арамис', 'лейтенант'],
# ['Балакирев', 'рядовой']]
order = 'рядовой, сержант, старшина, прапорщик, лейтенант, капитан, майор, подполковник, полковник'
lst = sorted(lst, key=lambda x: order.find(x[1]))
# lst=[['Балакирев', 'рядовой'], ['Портос', 'прапорщик'], ['Атос', 'лейтенант'], ['Арамис', 'лейтенант'],
# ["д'Артаньян", 'капитан']]
##################################
s = 'рядовой, сержант, старшина, прапорщик, лейтенант, капитан, майор, подполковник, полковник'
order = dict(zip(s.split(', '), range(9)))
print(order)  # {'рядовой': 0, ' сержант': 1, ' старшина': 2, ' прапорщик': 3, ' лейтенант': 4, ' капитан': 5, ' майор': 6,
# ' подполковник': 7, ' полковник': 8}

lst = list(i.split('=') for i in lst_in)
print(lst) #[['Атос', 'лейтенант'], ['Портос', 'прапорщик'], ["д'Артаньян", 'капитан'], ['Арамис', 'лейтенант'],
# ['Балакирев', 'рядовой']]

lst = sorted(lst, key=lambda x: order.get(x[1]))
##################################
lst = [i.split('=') for i in lst_in]
ranks = 'рядовойсержантстаршинапрапорщиклейтенанткапитанмайорподполковникполковник'
lst.sort(key=lambda x: ranks.index(x[1]))
#Метод index() находит подстроку в строке или конкретный символ. Поиск идёт слева на право, первое найденное
# соответствие будет возвращено в виде целого положительного числа, соответствующего номеру первого символа подстроки
# и его положение в строке. (В случае если не были заданы доп аргументы для поиска в конкретном месте строки)
# index() работает также как и find(). Основное отличие только в том, что если соответствующий элемент в строке не
# был найден, то index() бросит исключение, а find() вернёт -1.
#Если для строк Python использует алгоритм Кнута-Морриса-Пратта, то
# find() и index() имеют сложность поиска O (n + k)
# А вот поскольку словари  реализованы через хэш-таблицу, то поиск элемента в них имеет сложность O(1)
##################################  9.8 Функция isinstance для проверки типов данных #################################
#Подвиг 2. Определите функцию с именем get_add, которая складывает или два числа или две строки (но не число со
# строкой) и возвращает полученный результат. Если сложение не может быть выполнено, то функция возвращает значение None
def get_add(a, b):
    if type(a) in (int, float) and type(b) in (int, float):
        return a + b
    elif type(a) == type(b) and type(a) is str:
        return a + b
    else:
        return

print(get_add(2.1, '3'))
##################################
def get_add(a, b):
    if  {type(a), type(b)} in ({str}, {int}, {float}, {int, float}):
        return a + b
# {type(a), type(b)} вернет множество, в множестве, как Вы помните могут быть только уникальные значения, поэтому
# если типы данных будет у a и b одинаковые, тогда вернется {str}, {int}, {float}, а если разные {int, float} то
# вернется это, иначе вернется None.

##################################
def get_add(a, b):
    tset = {type(a), type(b)}
    if tset <= {int, float} or tset == {str}:
        return a + b
#оператор меньше < означает строгое подмножество
##################################
#Подвиг 3. Определите функцию с именем get_sum, которая принимает на входе итерируемый объект (список, строку, кортеж,
# словарь, множество) и вычисляет сумму только целых чисел, взятых из элементов итерируемого объекта. Вычисленная сумма
# возвращается функцией. Если целых чисел нет, то возвращается 0.
def get_sum(it):
    return sum(filter(lambda x: type(x) is int, it))
    return sum(filter(lambda x: type(x) == int, it))

print(get_sum([1, 2, 3, "a", True, [4, 5], "c", (4, 5)]))
print(get_sum({5, 6, 7, '8', 5, '4'}))
get_sum((10, "f", '33', True, 12))
get_sum(['1', True, False, (1, 23)])
##################################
get_sum = lambda x: sum(i for i in x if type(i) == int)
##################################
#Подвиг 4. Определите функцию с именем get_even_sum, которая принимает на входе итерируемый объект (список, строку,
# кортеж, словарь, множество) и вычисляет сумму только целых четных чисел, взятых из элементов итерируемого объекта.
# Результат возвращается функцией. Если целых чисел нет, то возвращается 0.
def get_even_sum(it):
    return sum(filter(lambda x: type(x) is int and not x % 2, it))
#функция sum имеет параметр по умолчанию, задающий начальное значение равное 0.
# sum(iterable, start=0) Если фильтр пустой, то возвращается 0.
# кстати так можно вложенные списки 'вытягивать' в одномерный список.
# >>> sum([[1, 2], [3, 4], [5, 6]], [])
# [1, 2, 3, 4, 5, 6]
# Такая запись суммы примерно эквивалентна циклу:
# start = []
# for i in [[1, 2], [3, 4], [5, 6]]:
#     start += i
#вот так работает, все остальные вариации с кортежами терпят неудачу.
# a = ([1, 2], [3, 4], [5, 6])
# print(sum(a, []))

#a = [[1, 2], [3, 4], [5, 6]]
# print(sum(a,[]))

# Если входной итерируемый объект содержит, например, строку, то в проверке условия type(x) == int and x % 2 == 0
# внутри filter, при условии, что они выполняются оба, должно возникать исключение TypeError.
# При вычислении остатка от деления строка на 2. Оказывается, что не возникает. Если первое условие не выполняется,
# то связанные с ним логическим сложением (and) условия даже не проверяются. В подобных ситуациях это удобно.
# В C/C++ пришлось бы вкладывать одну проверку в другую, т.к. оба выражения type(x) и x % 2 были бы вычислены до
# операций сравнения. То есть, если поменять условия местами x % 2 == 0 and type(x) == int, то ошибка все же
# появляется. Такие пироги.
print(get_even_sum({10, "f", '33', True, 12}))
##################################
#Как и в предыдущей задаче здесь нет смысла в производстве лишних действий в виде создания лямбда-функции внутри
# фильтра. Вместо этого функции sum проще передать генератор.
def get_sum(it):
    return sum(i for i in it if type(i) is int and not i % 2)

##################################
#Подвиг 5. Определите функцию с именем get_list_dig, которая возвращает список только из числовых значений
# переданной ей коллекции (список или кортеж).
def get_list_dig(lst):
    return list(filter(lambda x: type(x) in (int, float), lst))
##################################
def get_list_dig(lst):
    return [x for x in lst if type(x) in (int,float)]
##################################
def get_list_dig(lst):
    return [*filter(lambda x:type(x) in (int, float),lst)]
##################################  9.9 Функции all и any
#Подвиг 1. Вводится строка целых чисел через пробел. Необходимо определить, являются ли все эти числа четными.
# Вывести True, если это так и False - в противном случае.
s = '3 4 6 8 22 56 7'
print(all(map(lambda x: not int(x) % 2, s.split())))
print(all(map(lambda x: int(x) % 2 == 0, s.split())))
print(not any(map(lambda x: int(x) % 2, s.split())))
##################################
#Подвиг 2. Вводится строка вещественных чисел через пробел. Необходимо определить, есть ли среди них хотя бы одно
# отрицательное. Вывести True, если это так и False - в противном случае.
print(any(map(lambda x: float(x) < 0, s.split())))
print(not all(map(lambda x: float(x) > 0, s.split())))
s = '8.2 -11.0 20 3.4 -1.2'
print(any(True if float(i) < 0 else False for i in s.split()))

s = '8.2 -11.0 20 3.4 -1.2'
print('-' in s)
##################################
#Подвиг 3. Объявить функцию с именем is_string, на вход которой поступает коллекция (список, кортеж, множество).
# Она должна возвращать True, если все элементы коллекции строки и False - в противном случае.
def is_string(lst):
    return all(map(lambda x: type(x) is str, lst))

##################################
#Подвиг 4. Вводятся оценки студента в одну строчку через пробел. Необходимо определить, имеется ли в этом списке хотя
# бы одна оценка ниже тройки. Если это так, то вывести на экран строку "отчислен", иначе - "учится".
s = '3 3 3 2 3 3'
def study(s):
    if any(map(lambda x: int(x) == 2, s.split())):
        print('отчислен')
    else:
        print('учится')

if __name__ == '__main__':
    study(s)
##################################
print(['учится', 'отчислен'][any(map(lambda x: int(x) == 2, s.split()))])
##################################
#Подвиг 5. Вводится текущее игровое поле для игры "Крестики-нолики" в виде следующей таблицы:
# # x o
# x # x
# o o #
#Здесь # - свободная клетка. Нужно объявить функцию с именем is_free, на вход которой поступает игровое поле
# в виде двумерного (вложенного) списка. Данная функция должна возвращать True, если есть хотя бы одна свободная
# клетка и False - в противном случае.

# lst=list(map(str.strip,sys.stdin.readlines()))
lst = ['# x o', 'x x x', 'o o x']
def is_free(lst):
    return any(map(lambda x: '#' in x, lst))

if __name__ == '__main__':
    print(is_free(lst))
##################################
def is_free(lst):
    return any('#' in i for i in lst)
##################################
lst = ['# x o', 'x x x', 'o o x']
is_free = lambda x: list(map(lambda x: '#' in x, lst))
print(is_free(lst)) #[True, False, False]
##################################
lst = ['# x o', 'x x x', 'o o x']
is_free = lambda x: any(map(lambda x: '#' in x, lst))
print(is_free(lst)) #True
##################################
lst = ['# x o', 'x x x', 'o o x']
is_free = lambda x: list(map(lambda x: '#' in x, x))
print(is_free(lst))  # True
##################################

##################################  10.2 Битовые операции И, ИЛИ, НЕ, XOR  #######
#Подвиг 2. На вход программы подается целое десятичное число. Используя битовые операции, включите третий бит
# введенного числа. Выведите на экран полученное числовое значение.P. S. Распределение номеров бит представлено
# на следующем рисунке.
x=int(input())
res = x | (1<<3)
print(res)
##################################
x = 100
print(bin(x)) #0b1100100
mask = 18

print(bin(mask)) #0b1000
res = x | mask
print(res)
print(bin(res)) #0b1101100
##################################
#Подвиг 3. На вход программы подается целое десятичное число. Используя битовые операции,
# выключите 4-й и 1-й биты введенного числа. Выведите на экран полученное числовое значение.
x = 153 ## 0b1100100
print(bin(x))
print(int('0b11101101', 2))
mask = 237  # 0b111110111
print(bin(mask))  # mask: 0b111110110
res = x & mask
print(res)
print(bin(res))  # 0b1101100
print(int('0b10001001', 2))
print(bin(137))
##################################
res = x & ~(1 << 1) & ~(1 << 4)
##################################
print(int(input()) & ~18) #0b10010
##################################
mask=2**4+2**1 #18
print(num&~mask)
##################################
#Подвиг 4. На вход программы подается целое десятичное число. Используя битовые операции,
# переключите 3-й и 0-й биты введенного числа. Выведите на экран полученное числовое значение.
x=58 #0b111010
print(bin(x))
res = x ^ 0b001001
print(res)
x^= 0b001001
##################################
res = x ^ (1<<0)^(1<<3)
res = x ^ ((1<<0)|(1<<3))
##################################
##################################
##################################
#Подвиг 5. На вход программы подается целое десятичное число. Используя битовые операции, выполните умножение
# введенного числа на 4. Результат отобразите на экране.
x=int(input())
x=x<<2
##################################
#Подвиг 7. Вводится зашифрованное слово. Шифрование кодов символов этого слова было проведено с помощью битовой
# операции XOR с ключом key=123. То есть, каждый символ был преобразован по алгоритму:
# x = ord(x) ^ key
# Здесь ord - функция, возвращающая код символа x. Расшифруйте введенное слово и выведите его на экран.
s = 'ѩкю[щюлцхZ'
key = 123
def ord_get(s):
    [print(chr(i),end='') for i in (ord(i)^key for i in s)]

if __name__ == '__main__':
    ord_get(s)
##################################
print(''.join(chr(i) for i in (ord(i) ^ key for i in s)))
##################################
#Подвиг 8. На вход программы подается целое десятичное число. Используя битовые операции, проверьте,
# включен ли 6-й и 3-й биты введенного числа. Если они оба включены, то выведите слово ДА, иначе - слово НЕТ.
s = 106
s=int(input())
# print(bin(s))
mask=0b1001000
if mask& s==mask:
    print('ДА')
else:
    print('НЕТ')
##################################
if s & (1<<3) and s &(1<<6):
    print('ДА')
else:
    print('НЕТ')
##################################
mask=0b1001000
print(int('0b1001000',2))
print(('НЕТ', 'ДА')[int(input()) & 72 == 72])
##################################
#Подвиг 9. На вход программы подается целое десятичное число. Используя битовые операции, проверьте, включен ли 5-й
# или 1-й биты введенного числа. Если включен хотя бы один из этих битов, то выведите слово ДА, иначе - слово НЕТ.
if s &(1<<1) or s & (1<<5):
    print('ДА')
else:
    print('НЕТ')
##################################
print('ДА' if s & (1 << 1) or s & (1 << 5) else 'НЕТ')
##################################
#Подвиг 2. Вводятся два натуральных числа a, b (a < b) в одну строчку через пробел. Выполните генерацию вещественной
# случайной величины в диапазоне [a; b). Округлите результат до сотых и выведите его на экран.
import random
random.seed(1)
n=  list(map(int,  input().split()))
print(round(random.uniform(*n),2))
##################################
a,b=  map(int,  s.split())
print(round(random.uniform(a,b-0.01),2))
##################################
print(f'{random.uniform(a, b):.2f}')
##################################
#Подвиг 3. Вводятся два натуральных числа a, b (a < b) в одну строчку через пробел. Выполните генерацию
# целочисленной случайной величины в диапазоне [a; b]. Выведите результат на экран.
a,b=  list(map(int,  input().split()))
print(random.randint(a,b))
##################################
print(random.randrange(a,b))
##################################
#Подвиг 4. Вводится список названий городов в одну строчку через пробел. Выберите из этого списка один город
# случайным образом и отобразите его на экране.
import random
random.seed(1)
s='Тула Казань Смоленск Семипалатинск Уфа Москва Самара'.split()
print(random.choice(s))
##################################
#Подвиг 5. Вводится таблица целых чисел, записанных через пробел. Необходимо перемешать столбцы этой таблицы,
# используя функции shuffle и zip и вывести результат на экран (также в виде таблицы).
random.seed(1)

# считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

lst_in = ['1 2 3 4', '5 6 7 8', '9 8 6 7']

lst = list(list(int(j) for j in i.split()) for i in lst_in) #[[1, 2, 3, 4], [5, 6, 7, 8], [9, 8, 6, 7]]
# lst = list(list(map(int,i.split())) for i in lst_in)
print(lst) #[[1, 2, 3, 4], [5, 6, 7, 8], [9, 8, 6, 7]]

lz=list(zip(*lst)) #[(1, 5, 9), (2, 6, 8), (3, 7, 6), (4, 8, 7)]


random.shuffle(lz) #[(4, 8, 7), (1, 5, 9), (3, 7, 6), (2, 6, 8)]
print(lz) #[(4, 8, 7), (1, 5, 9), (3, 7, 6), (2, 6, 8)]

z2 = list(zip(*lz)) #[(4, 1, 3, 2), (8, 5, 7, 6), (7, 9, 6, 8)]
print(z2)
for i in z2:
    print(*i)
#4 1 3 2
# 8 5 7 6
# 7 9 6 8
##################################
lst_in = ['1 2 3 4', '5 6 7 8', '9 8 6 7']
lst = list(zip(*map(str.split, lst_in)))
random.shuffle(lst)
l=list(zip(*lst))
[print(*i) for i in l]
##################################
lst = list(zip(*[i.split() for i in lst_in]))
random.shuffle(lst)
##################################
columns = list(zip(*map(str.split, sys.stdin)))
rnd.seed(1)
rnd.shuffle(columns)
for row in zip(*columns):
    print(*row)
##################################
import random

random.seed(1)
arr = [*zip(*map(str.split, open(0)))]
random.shuffle(arr)
[print(*row) for row in zip(*arr)]
##################################
lst_in = list(map(str.strip, sys.stdin.readlines()))
lst_in = list(zip(*map(str.split, lst_in)))
random.shuffle(lst_in)

[print(*_) for _ in zip(*lst_in)]
##################################
#Подвиг 6. Вводятся имена студентов в одну строчку через пробел. Требуется случайным образом выбрать трех
# студентов из этого списка, используя функцию sample. (Полагается, что в исходном списке более трех студентов).
# Результат вывести на экран в одну строчку через пробел.
s = 'Петров Иванов Сидоров Балакирев Фридман'
print(*random.sample(s.split(), 3))
##################################
import random as rnd
rnd.seed(1)
print(*rnd.sample(input().split(), 3))
##################################
#Значимый подвиг 7. Имеется двумерное игровое поле размером N x N (N - натуральное число, вводится с клавиатуры)
# , представленное в виде вложенного списка:
# P = [[0] * N for i in range(N)]
# Требуется расставить в нем случайным образом M = 10 единиц (целочисленных) так, чтобы они не соприкасались
# друг с другом (то есть, вокруг каждой единицы должны быть нули, либо граница поля).
N = 10
P = [[0] * N for i in range(N)]
[print(i)for i in P]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
import random
import numpy as np  # импортируем в задачу модуль
# установка "зерна" датчика случайных чисел, чтобы получались одни и те же случайные величины
random.seed(1)
# начальная инициализация поля (переменные P и N не менять, единицы записывать в список P)
N = 10
P = [[0] * N for i in range(N)]

# здесь продолжайте программу
# функция проверяет что соседние клетки не содержат 1
def is_isolate(i, j):
    return sum([P[i - 1][j - 1], P[i - 1][j], P[i - 1][j + 1],
                P[i][j - 1], P[i][j + 1], P[i + 1][j - 1],
                P[i + 1][j], P[i + 1][j + 1]]) == 0


# строим границу из нулей вокруг матрицы P
P = np.pad(P, pad_width=1, mode='constant', constant_values=0)

# Заполняем поле 10-ю минами
for _ in range(10):
    while True:
        # генерируем координаты ячейки пока не найдём свободную от 1 и с 0 вокруг
        row = random.randint(1, N - 3)  # при N - 2 время не хватит для решения
        column = random.randint(1, N - 2)
        # если ячейка свободная, то занимаем её
        if is_isolate(row, column) and P[row][column] != 1:
            P[row][column] = 1
            break
##################################
from random import randrange, seed
seed(1)
N = int(input())
P = [[0] * N for i in range(N)]

while sum(map(sum, P)) < 10:
    P[randrange(0, N, 2)][randrange(0, N, 2)] = 1
##################################
#
##################################

##################################

#################